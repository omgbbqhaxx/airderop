{"ast":null,"code":"/* eslint-disable no-continue */\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable no-param-reassign */\n\n/* eslint-disable no-prototype-builtins */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar errorClasses = {};\nvar deserializers = {};\nexport var addCustomErrorDeserializer = function (name, deserializer) {\n  deserializers[name] = deserializer;\n};\nexport var createCustomErrorClass = function (name) {\n  var CustomErrorClass =\n  /** @class */\n  function (_super) {\n    __extends(CustomErrorClass, _super);\n\n    function CustomErrorClass(message, fields, options) {\n      var _this = // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      _super.call(this, message || name, options) || this; // Set the prototype explicitly. See https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n\n\n      Object.setPrototypeOf(_this, CustomErrorClass.prototype);\n      _this.name = name;\n\n      if (fields) {\n        for (var k in fields) {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          _this[k] = fields[k];\n        }\n      }\n\n      if (isObject(options) && \"cause\" in options && !(\"cause\" in _this)) {\n        // .cause was specified but the superconstructor\n        // did not create an instance property.\n        var cause = options.cause;\n        _this.cause = cause;\n\n        if (\"stack\" in cause) {\n          _this.stack = _this.stack + \"\\nCAUSE: \" + cause.stack;\n        }\n      }\n\n      return _this;\n    }\n\n    return CustomErrorClass;\n  }(Error);\n\n  errorClasses[name] = CustomErrorClass;\n  return CustomErrorClass;\n};\n\nfunction isObject(value) {\n  return value !== null && typeof value === \"object\";\n} // inspired from https://github.com/programble/errio/blob/master/index.js\n\n\nexport var deserializeError = function (object) {\n  if (typeof object === \"object\" && object) {\n    try {\n      // $FlowFixMe FIXME HACK\n      var msg = JSON.parse(object.message);\n\n      if (msg.message && msg.name) {\n        object = msg;\n      }\n    } catch (e) {// nothing\n    }\n\n    var error = void 0;\n\n    if (typeof object.name === \"string\") {\n      var name_1 = object.name;\n      var des = deserializers[name_1];\n\n      if (des) {\n        error = des(object);\n      } else {\n        var constructor = name_1 === \"Error\" ? Error : errorClasses[name_1];\n\n        if (!constructor) {\n          console.warn(\"deserializing an unknown class '\" + name_1 + \"'\");\n          constructor = createCustomErrorClass(name_1);\n        }\n\n        error = Object.create(constructor.prototype);\n\n        try {\n          for (var prop in object) {\n            if (object.hasOwnProperty(prop)) {\n              error[prop] = object[prop];\n            }\n          }\n        } catch (e) {// sometimes setting a property can fail (e.g. .name)\n        }\n      }\n    } else {\n      error = new Error(object.message);\n    }\n\n    if (!error.stack && Error.captureStackTrace) {\n      Error.captureStackTrace(error, deserializeError);\n    }\n\n    return error;\n  }\n\n  return new Error(String(object));\n}; // inspired from https://github.com/sindresorhus/serialize-error/blob/master/index.js\n\nexport var serializeError = function (value) {\n  if (!value) return value;\n\n  if (typeof value === \"object\") {\n    return destroyCircular(value, []);\n  }\n\n  if (typeof value === \"function\") {\n    return \"[Function: \".concat(value.name || \"anonymous\", \"]\");\n  }\n\n  return value;\n}; // https://www.npmjs.com/package/destroy-circular\n\nfunction destroyCircular(from, seen) {\n  var e_1, _a;\n\n  var to = {};\n  seen.push(from);\n\n  try {\n    for (var _b = __values(Object.keys(from)), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var key = _c.value;\n      var value = from[key];\n\n      if (typeof value === \"function\") {\n        continue;\n      }\n\n      if (!value || typeof value !== \"object\") {\n        to[key] = value;\n        continue;\n      }\n\n      if (seen.indexOf(from[key]) === -1) {\n        to[key] = destroyCircular(from[key], seen.slice(0));\n        continue;\n      }\n\n      to[key] = \"[Circular]\";\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b[\"return\"])) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  if (typeof from.name === \"string\") {\n    to.name = from.name;\n  }\n\n  if (typeof from.message === \"string\") {\n    to.message = from.message;\n  }\n\n  if (typeof from.stack === \"string\") {\n    to.stack = from.stack;\n  }\n\n  return to;\n} //# sourceMappingURL=helpers.js.map","map":null,"metadata":{},"sourceType":"module"}