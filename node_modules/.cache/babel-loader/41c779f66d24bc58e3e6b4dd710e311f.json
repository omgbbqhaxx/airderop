{"ast":null,"code":"import { PublicKey } from '@solana/web3.js';\nimport QRCodeModal from '@walletconnect/qrcode-modal';\nimport WalletConnectClient from '@walletconnect/sign-client';\nimport { getSdkError, parseAccountId } from '@walletconnect/utils';\nimport base58 from 'bs58';\nimport { ClientNotInitializedError, QRCodeModalError } from './errors.js';\nexport var WalletConnectChainID;\n\n(function (WalletConnectChainID) {\n  WalletConnectChainID[\"Mainnet\"] = \"solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ\";\n  WalletConnectChainID[\"Devnet\"] = \"solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K\";\n})(WalletConnectChainID || (WalletConnectChainID = {}));\n\nexport var WalletConnectRPCMethods;\n\n(function (WalletConnectRPCMethods) {\n  WalletConnectRPCMethods[\"signTransaction\"] = \"solana_signTransaction\";\n  WalletConnectRPCMethods[\"signMessage\"] = \"solana_signMessage\";\n})(WalletConnectRPCMethods || (WalletConnectRPCMethods = {}));\n\nconst getConnectParams = (chainId, pairingTopic) => ({\n  requiredNamespaces: {\n    solana: {\n      chains: [chainId],\n      methods: [WalletConnectRPCMethods.signTransaction, WalletConnectRPCMethods.signMessage],\n      events: []\n    }\n  },\n  pairingTopic\n});\n\nexport class WalletConnectWallet {\n  constructor(config) {\n    this._options = config.options;\n    this._network = config.network;\n  }\n\n  async connect() {\n    const client = this._client ?? (await WalletConnectClient.init(this._options));\n    const sessions = client.find(getConnectParams(this._network)).filter(s => s.acknowledged);\n\n    if (sessions.length) {\n      // select last matching session\n      this._session = sessions[sessions.length - 1]; // We assign this variable only after we're sure we've received approval\n\n      this._client = client;\n      return {\n        publicKey: this.publicKey\n      };\n    } else {\n      const {\n        uri,\n        approval\n      } = await client.connect(getConnectParams(this._network));\n      return new Promise((resolve, reject) => {\n        if (uri) {\n          QRCodeModal.open(uri, () => {\n            reject(new QRCodeModalError());\n          });\n        }\n\n        approval().then(session => {\n          this._session = session; // We assign this variable only after we're sure we've received approval\n\n          this._client = client;\n          resolve({\n            publicKey: this.publicKey\n          });\n        }).catch(reject).finally(() => {\n          QRCodeModal.close();\n        });\n      });\n    }\n  }\n\n  async disconnect() {\n    if (this._client && this._session) {\n      await this._client.disconnect({\n        topic: this._session.topic,\n        reason: getSdkError('USER_DISCONNECTED')\n      });\n      this._session = undefined;\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n\n  get client() {\n    if (this._client) {\n      // TODO: using client.off throws an error\n      return Object.assign({}, this._client, {\n        off: this._client.removeListener\n      }); // return this._client;\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n\n  get publicKey() {\n    if (this._client && this._session) {\n      const {\n        address\n      } = parseAccountId(this._session.namespaces.solana.accounts[0]);\n      return new PublicKey(address);\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n\n  async signTransaction(transaction) {\n    if (this._client && this._session) {\n      const {\n        signature\n      } = await this._client.request({\n        chainId: this._network,\n        topic: this._session.topic,\n        request: {\n          method: WalletConnectRPCMethods.signTransaction,\n          params: { ...transaction\n          }\n        }\n      });\n      transaction.addSignature(this.publicKey, Buffer.from(base58.decode(signature)));\n      return transaction;\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n\n  async signMessage(message) {\n    if (this._client && this._session) {\n      const {\n        signature\n      } = await this._client.request({\n        // The network does not change the output of message signing, but this is a required parameter for SignClient\n        chainId: this._network,\n        topic: this._session.topic,\n        request: {\n          method: WalletConnectRPCMethods.signMessage,\n          params: {\n            pubkey: this.publicKey.toString(),\n            message: base58.encode(message)\n          }\n        }\n      });\n      return base58.decode(signature);\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n\n} //# sourceMappingURL=adapter.js.map","map":null,"metadata":{},"sourceType":"module"}